/* eslint-disable */
const canUseDOM=!!("undefined"!==typeof window&&window.document&&window.document.createElement),getConfirmation=(message,callback)=>callback(window.confirm(message)),supportsHistory=()=>{const ua=window.navigator.userAgent;if((-1!==ua.indexOf("Android 2.")||-1!==ua.indexOf("Android 4.0"))&&-1!==ua.indexOf("Mobile Safari")&&-1===ua.indexOf("Chrome")&&-1===ua.indexOf("Windows Phone"))return!1;return window.history&&"pushState"in window.history},supportsPopStateOnHashChange=()=>-1===window.navigator.userAgent.indexOf("Trident"),supportsGoWithoutReloadUsingHash=()=>-1===window.navigator.userAgent.indexOf("Firefox"),isExtraneousPopstateEvent=event=>event.state===void 0&&-1===navigator.userAgent.indexOf("CriOS");var DOMUtils={canUseDOM:canUseDOM,getConfirmation:getConfirmation,supportsHistory:supportsHistory,supportsPopStateOnHashChange:supportsPopStateOnHashChange,supportsGoWithoutReloadUsingHash:supportsGoWithoutReloadUsingHash,isExtraneousPopstateEvent:isExtraneousPopstateEvent};function isAbsolute(pathname){return"/"===pathname.charAt(0)}function spliceOne(list,index){for(let i=index,k=i+1,n=list.length;k<n;i+=1,k+=1){list[i]=list[k]}list.pop()}function resolvePathname(to,from=""){const toParts=to&&to.split("/")||[];let fromParts=from&&from.split("/")||[];const isToAbs=to&&isAbsolute(to),isFromAbs=from&&isAbsolute(from),mustEndAbs=isToAbs||isFromAbs;if(to&&isAbsolute(to)){fromParts=toParts}else if(toParts.length){fromParts.pop();fromParts=fromParts.concat(toParts)}if(!fromParts.length)return"/";let hasTrailingSlash;if(fromParts.length){const last=fromParts[fromParts.length-1];hasTrailingSlash="."===last||".."===last||""===last}else{hasTrailingSlash=!1}let up=0;for(let i=fromParts.length;0<=i;i--){const part=fromParts[i];if("."===part){spliceOne(fromParts,i)}else if(".."===part){spliceOne(fromParts,i);up++}else if(up){spliceOne(fromParts,i);up--}}if(!mustEndAbs)for(;up--;up)fromParts.unshift("..");if(mustEndAbs&&""!==fromParts[0]&&(!fromParts[0]||!isAbsolute(fromParts[0])))fromParts.unshift("");let result=fromParts.join("/");if(hasTrailingSlash&&"/"!==result.substr(-1))result+="/";return result}var resolvePathname$1={default:resolvePathname};function valueEqual(a,b){if(a===b)return!0;if(null==a||null==b)return!1;if(Array.isArray(a)){return Array.isArray(b)&&a.length===b.length&&a.every(function(item,index){return valueEqual(item,b[index])})}const aType=typeof a;if(aType!==typeof b)return!1;if("object"===aType){const aValue=a.valueOf(),bValue=b.valueOf();if(aValue!==a||bValue!==b)return valueEqual(aValue,bValue);const aKeys=Object.keys(a),bKeys=Object.keys(b);if(aKeys.length!==bKeys.length)return!1;return aKeys.every(function(key){return valueEqual(a[key],b[key])})}return!1}var valueEqual$1={default:valueEqual};const addLeadingSlash=path=>"/"===path.charAt(0)?path:"/"+path,stripLeadingSlash=path=>"/"===path.charAt(0)?path.substr(1):path,hasBasename=(path,prefix)=>new RegExp("^"+prefix+"(\\/|\\?|#|$)","i").test(path),stripBasename=(path,prefix)=>hasBasename(path,prefix)?path.substr(prefix.length):path,stripTrailingSlash=path=>"/"===path.charAt(path.length-1)?path.slice(0,-1):path,parsePath=path=>{let pathname=path||"/",search="",hash="";const hashIndex=pathname.indexOf("#");if(-1!==hashIndex){hash=pathname.substr(hashIndex);pathname=pathname.substr(0,hashIndex)}const searchIndex=pathname.indexOf("?");if(-1!==searchIndex){search=pathname.substr(searchIndex);pathname=pathname.substr(0,searchIndex)}return{pathname,search:"?"===search?"":search,hash:"#"===hash?"":hash}},createPath=location=>{const{pathname,search,hash}=location;let path=pathname||"/";if(search&&"?"!==search)path+="?"===search.charAt(0)?search:`?${search}`;if(hash&&"#"!==hash)path+="#"===hash.charAt(0)?hash:`#${hash}`;return path};var PathUtils={addLeadingSlash:addLeadingSlash,stripLeadingSlash:stripLeadingSlash,hasBasename:hasBasename,stripBasename:stripBasename,stripTrailingSlash:stripTrailingSlash,parsePath:parsePath,createPath:createPath};const createLocation=(path,state,key,currentLocation)=>{let location;if("string"===typeof path){location=parsePath(path);location.state=state}else{location={...path};if(location.pathname===void 0)location.pathname="";if(location.search){if("?"!==location.search.charAt(0))location.search="?"+location.search}else{location.search=""}if(location.hash){if("#"!==location.hash.charAt(0))location.hash="#"+location.hash}else{location.hash=""}if(state!==void 0&&location.state===void 0)location.state=state}try{location.pathname=decodeURI(location.pathname)}catch(e){if(e instanceof URIError){throw new URIError("Pathname \""+location.pathname+"\" could not be decoded. "+"This is likely caused by an invalid percent-encoding.")}else{throw e}}if(key)location.key=key;if(currentLocation){if(!location.pathname){location.pathname=currentLocation.pathname}else if("/"!==location.pathname.charAt(0)){location.pathname=resolvePathname(location.pathname,currentLocation.pathname)}}else{if(!location.pathname){location.pathname="/"}}return location},locationsAreEqual=(a,b)=>a.pathname===b.pathname&&a.search===b.search&&a.hash===b.hash&&a.key===b.key&&valueEqual(a.state,b.state);var LocationUtils={createLocation:createLocation,locationsAreEqual:locationsAreEqual};var __DEV__="production"!==process.env.NODE_ENV,warning=function(){};if(__DEV__){var printWarning=function(format,args){var len=arguments.length;args=Array(2<len?len-2:0);for(var key=2;key<len;key++){args[key-2]=arguments[key]}var argIndex=0,message="Warning: "+format.replace(/%s/g,function(){return args[argIndex++]});if("undefined"!==typeof console){console.error(message)}try{throw new Error(message)}catch(x){}};warning=function(condition,format,args){var len=arguments.length;args=Array(2<len?len-2:0);for(var key=2;key<len;key++){args[key-2]=arguments[key]}if(format===void 0){throw new Error("`warning(condition, format, ...args)` requires a warning "+"message argument")}if(!condition){printWarning.apply(null,[format].concat(args))}}}var warning$1=warning,warning$2={default:warning$1};var NODE_ENV=process.env.NODE_ENV,invariant=function(condition,format,a,b,c,d,e,f){if("production"!==NODE_ENV){if(format===void 0){throw new Error("invariant requires an error message argument")}}if(!condition){var error;if(format===void 0){error=new Error("Minified exception occurred; use the non-minified dev environment "+"for the full error message and additional helpful warnings.")}else{var args=[a,b,c,d,e,f],argIndex=0;error=new Error(format.replace(/%s/g,function(){return args[argIndex++]}));error.name="Invariant Violation"}error.framesToPop=1;throw error}},invariant$1={default:invariant};const createTransitionManager=()=>{let prompt=null;const setPrompt=nextPrompt=>{warning$1(null==prompt,"A history supports only one prompt at a time");prompt=nextPrompt;return()=>{if(prompt===nextPrompt)prompt=null}},confirmTransitionTo=(location,action,getUserConfirmation,callback)=>{if(null!=prompt){const result="function"===typeof prompt?prompt(location,action):prompt;if("string"===typeof result){if("function"===typeof getUserConfirmation){getUserConfirmation(result,callback)}else{warning$1(!1,"A history needs a getUserConfirmation function in order to use a prompt message");callback(!0)}}else{callback(!1!==result)}}else{callback(!0)}};let listeners=[];const appendListener=fn=>{let isActive=!0;const listener=(...args)=>{if(isActive)fn(...args)};listeners.push(listener);return()=>{isActive=!1;listeners=listeners.filter(item=>item!==listener)}},notifyListeners=(...args)=>{listeners.forEach(listener=>listener(...args))};return{setPrompt,confirmTransitionTo,appendListener,notifyListeners}};var createTransitionManager$1={default:createTransitionManager};const PopStateEvent="popstate",HashChangeEvent="hashchange",getHistoryState=()=>{try{return window.history.state||{}}catch(e){return{}}},createBrowserHistory=(props={})=>{invariant(canUseDOM,"Browser history needs a DOM");const globalHistory=window.history,canUseHistory=supportsHistory(),needsHashChangeListener=!supportsPopStateOnHashChange(),{forceRefresh=!1,getUserConfirmation=getConfirmation,keyLength=6}=props,basename=props.basename?stripTrailingSlash(addLeadingSlash(props.basename)):"",getDOMLocation=historyState=>{const{key,state}=historyState||{},{pathname,search,hash}=window.location;let path=pathname+search+hash;warning$1(!basename||hasBasename(path,basename),"You are attempting to use a basename on a page whose URL path does not begin "+"with the basename. Expected path \""+path+"\" to begin with \""+basename+"\".");if(basename)path=stripBasename(path,basename);return createLocation(path,state,key)},createKey=()=>Math.random().toString(36).substr(2,keyLength),transitionManager=createTransitionManager(),setState=nextState=>{Object.assign(history,nextState);history.length=globalHistory.length;transitionManager.notifyListeners(history.location,history.action)},handlePopState=event=>{if(isExtraneousPopstateEvent(event))return;handlePop(getDOMLocation(event.state))},handleHashChange=()=>{handlePop(getDOMLocation(getHistoryState()))};let forceNextPop=!1;const handlePop=location=>{if(forceNextPop){forceNextPop=!1;setState()}else{const action="POP";transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(ok){setState({action,location})}else{revertPop(location)}})}},revertPop=fromLocation=>{const toLocation=history.location;let toIndex=allKeys.indexOf(toLocation.key);if(-1===toIndex)toIndex=0;let fromIndex=allKeys.indexOf(fromLocation.key);if(-1===fromIndex)fromIndex=0;const delta=toIndex-fromIndex;if(delta){forceNextPop=!0;go(delta)}},initialLocation=getDOMLocation(getHistoryState());let allKeys=[initialLocation.key];const createHref=location=>basename+createPath(location),go=n=>{globalHistory.go(n)};let listenerCount=0;const checkDOMListeners=delta=>{listenerCount+=delta;if(1===listenerCount){window.addEventListener(PopStateEvent,handlePopState);if(needsHashChangeListener)window.addEventListener(HashChangeEvent,handleHashChange)}else if(0===listenerCount){window.removeEventListener(PopStateEvent,handlePopState);if(needsHashChangeListener)window.removeEventListener(HashChangeEvent,handleHashChange)}};let isBlocked=!1;const block=(prompt=!1)=>{const unblock=transitionManager.setPrompt(prompt);if(!isBlocked){checkDOMListeners(1);isBlocked=!0}return()=>{if(isBlocked){isBlocked=!1;checkDOMListeners(-1)}return unblock()}},history={length:globalHistory.length,action:"POP",location:initialLocation,createHref,push:(path,state)=>{warning$1(!("object"===typeof path&&path.state!==void 0&&state!==void 0),"You should avoid providing a 2nd state argument to push when the 1st "+"argument is a location-like object that already has state; it is ignored");const action="PUSH",location=createLocation(path,state,createKey(),history.location);transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(!ok)return;const href=createHref(location),{key,state}=location;if(canUseHistory){globalHistory.pushState({key,state},null,href);if(forceRefresh){window.location.href=href}else{const prevIndex=allKeys.indexOf(history.location.key),nextKeys=allKeys.slice(0,-1===prevIndex?0:prevIndex+1);nextKeys.push(location.key);allKeys=nextKeys;setState({action,location})}}else{warning$1(state===void 0,"Browser history cannot push state in browsers that do not support HTML5 history");window.location.href=href}})},replace:(path,state)=>{warning$1(!("object"===typeof path&&path.state!==void 0&&state!==void 0),"You should avoid providing a 2nd state argument to replace when the 1st "+"argument is a location-like object that already has state; it is ignored");const action="REPLACE",location=createLocation(path,state,createKey(),history.location);transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(!ok)return;const href=createHref(location),{key,state}=location;if(canUseHistory){globalHistory.replaceState({key,state},null,href);if(forceRefresh){window.location.replace(href)}else{const prevIndex=allKeys.indexOf(history.location.key);if(-1!==prevIndex)allKeys[prevIndex]=location.key;setState({action,location})}}else{warning$1(state===void 0,"Browser history cannot replace state in browsers that do not support HTML5 history");window.location.replace(href)}})},go,goBack:()=>go(-1),goForward:()=>go(1),block,listen:listener=>{const unlisten=transitionManager.appendListener(listener);checkDOMListeners(1);return()=>{checkDOMListeners(-1);unlisten()}}};return history};var createBrowserHistory$1={default:createBrowserHistory};const HashChangeEvent$1="hashchange",HashPathCoders={hashbang:{encodePath:path=>"!"===path.charAt(0)?path:"!/"+stripLeadingSlash(path),decodePath:path=>"!"===path.charAt(0)?path.substr(1):path},noslash:{encodePath:stripLeadingSlash,decodePath:addLeadingSlash},slash:{encodePath:addLeadingSlash,decodePath:addLeadingSlash}},getHashPath=()=>{const href=window.location.href,hashIndex=href.indexOf("#");return-1===hashIndex?"":href.substring(hashIndex+1)},pushHashPath=path=>window.location.hash=path,replaceHashPath=path=>{const hashIndex=window.location.href.indexOf("#");window.location.replace(window.location.href.slice(0,0<=hashIndex?hashIndex:0)+"#"+path)},createHashHistory=(props={})=>{invariant(canUseDOM,"Hash history needs a DOM");const globalHistory=window.history,canGoWithoutReload=supportsGoWithoutReloadUsingHash(),{getUserConfirmation=getConfirmation,hashType="slash"}=props,basename=props.basename?stripTrailingSlash(addLeadingSlash(props.basename)):"",{encodePath,decodePath}=HashPathCoders[hashType],getDOMLocation=()=>{let path=decodePath(getHashPath());warning$1(!basename||hasBasename(path,basename),"You are attempting to use a basename on a page whose URL path does not begin "+"with the basename. Expected path \""+path+"\" to begin with \""+basename+"\".");if(basename)path=stripBasename(path,basename);return createLocation(path)},transitionManager=createTransitionManager(),setState=nextState=>{Object.assign(history,nextState);history.length=globalHistory.length;transitionManager.notifyListeners(history.location,history.action)};let forceNextPop=!1,ignorePath=null;const handleHashChange=()=>{const path=getHashPath(),encodedPath=encodePath(path);if(path!==encodedPath){replaceHashPath(encodedPath)}else{const location=getDOMLocation(),prevLocation=history.location;if(!forceNextPop&&locationsAreEqual(prevLocation,location))return;if(ignorePath===createPath(location))return;ignorePath=null;handlePop(location)}},handlePop=location=>{if(forceNextPop){forceNextPop=!1;setState()}else{const action="POP";transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(ok){setState({action,location})}else{revertPop(location)}})}},revertPop=fromLocation=>{const toLocation=history.location;let toIndex=allPaths.lastIndexOf(createPath(toLocation));if(-1===toIndex)toIndex=0;let fromIndex=allPaths.lastIndexOf(createPath(fromLocation));if(-1===fromIndex)fromIndex=0;const delta=toIndex-fromIndex;if(delta){forceNextPop=!0;go(delta)}},path=getHashPath(),encodedPath=encodePath(path);if(path!==encodedPath)replaceHashPath(encodedPath);const initialLocation=getDOMLocation();let allPaths=[createPath(initialLocation)];const go=n=>{warning$1(canGoWithoutReload,"Hash history go(n) causes a full page reload in this browser");globalHistory.go(n)};let listenerCount=0;const checkDOMListeners=delta=>{listenerCount+=delta;if(1===listenerCount){window.addEventListener(HashChangeEvent$1,handleHashChange)}else if(0===listenerCount){window.removeEventListener(HashChangeEvent$1,handleHashChange)}};let isBlocked=!1;const block=(prompt=!1)=>{const unblock=transitionManager.setPrompt(prompt);if(!isBlocked){checkDOMListeners(1);isBlocked=!0}return()=>{if(isBlocked){isBlocked=!1;checkDOMListeners(-1)}return unblock()}},history={length:globalHistory.length,action:"POP",location:initialLocation,createHref:location=>"#"+encodePath(basename+createPath(location)),push:(path,state)=>{warning$1(state===void 0,"Hash history cannot push state; it is ignored");const action="PUSH",location=createLocation(path,void 0,void 0,history.location);transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(!ok)return;const path=createPath(location),encodedPath=encodePath(basename+path),hashChanged=getHashPath()!==encodedPath;if(hashChanged){ignorePath=path;pushHashPath(encodedPath);const prevIndex=allPaths.lastIndexOf(createPath(history.location)),nextPaths=allPaths.slice(0,-1===prevIndex?0:prevIndex+1);nextPaths.push(path);allPaths=nextPaths;setState({action,location})}else{warning$1(!1,"Hash history cannot PUSH the same path; a new entry will not be added to the history stack");setState()}})},replace:(path,state)=>{warning$1(state===void 0,"Hash history cannot replace state; it is ignored");const action="REPLACE",location=createLocation(path,void 0,void 0,history.location);transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(!ok)return;const path=createPath(location),encodedPath=encodePath(basename+path),hashChanged=getHashPath()!==encodedPath;if(hashChanged){ignorePath=path;replaceHashPath(encodedPath)}const prevIndex=allPaths.indexOf(createPath(history.location));if(-1!==prevIndex)allPaths[prevIndex]=path;setState({action,location})})},go,goBack:()=>go(-1),goForward:()=>go(1),block,listen:listener=>{const unlisten=transitionManager.appendListener(listener);checkDOMListeners(1);return()=>{checkDOMListeners(-1);unlisten()}}};return history};var createHashHistory$1={default:createHashHistory};const clamp=(n,lowerBound,upperBound)=>Math.min(Math.max(n,lowerBound),upperBound),createMemoryHistory=(props={})=>{const{getUserConfirmation,initialEntries=["/"],initialIndex=0,keyLength=6}=props,transitionManager=createTransitionManager(),setState=nextState=>{Object.assign(history,nextState);history.length=history.entries.length;transitionManager.notifyListeners(history.location,history.action)},createKey=()=>Math.random().toString(36).substr(2,keyLength),index=clamp(initialIndex,0,initialEntries.length-1),entries=initialEntries.map(entry=>"string"===typeof entry?createLocation(entry,void 0,createKey()):createLocation(entry,void 0,entry.key||createKey())),go=n=>{const nextIndex=clamp(history.index+n,0,history.entries.length-1),action="POP",location=history.entries[nextIndex];transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(ok){setState({action,location,index:nextIndex})}else{setState()}})},history={length:entries.length,action:"POP",location:entries[index],index,entries,createHref:createPath,push:(path,state)=>{warning$1(!("object"===typeof path&&path.state!==void 0&&state!==void 0),"You should avoid providing a 2nd state argument to push when the 1st "+"argument is a location-like object that already has state; it is ignored");const action="PUSH",location=createLocation(path,state,createKey(),history.location);transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(!ok)return;const prevIndex=history.index,nextIndex=prevIndex+1,nextEntries=history.entries.slice(0);if(nextEntries.length>nextIndex){nextEntries.splice(nextIndex,nextEntries.length-nextIndex,location)}else{nextEntries.push(location)}setState({action,location,index:nextIndex,entries:nextEntries})})},replace:(path,state)=>{warning$1(!("object"===typeof path&&path.state!==void 0&&state!==void 0),"You should avoid providing a 2nd state argument to replace when the 1st "+"argument is a location-like object that already has state; it is ignored");const action="REPLACE",location=createLocation(path,state,createKey(),history.location);transitionManager.confirmTransitionTo(location,action,getUserConfirmation,ok=>{if(!ok)return;history.entries[history.index]=location;setState({action,location})})},go,goBack:()=>go(-1),goForward:()=>go(1),canGo:n=>{const nextIndex=history.index+n;return 0<=nextIndex&&nextIndex<history.entries.length},block:(prompt=!1)=>transitionManager.setPrompt(prompt),listen:listener=>transitionManager.appendListener(listener)};return history};var createMemoryHistory$1={default:createMemoryHistory},index={createBrowserHistory:createBrowserHistory,createHashHistory:createHashHistory,createMemoryHistory:createMemoryHistory,createLocation:createLocation,locationsAreEqual:locationsAreEqual,parsePath:parsePath,createPath:createPath};export{DOMUtils as $DOMUtils,LocationUtils as $LocationUtils,PathUtils as $PathUtils,createBrowserHistory$1 as $createBrowserHistory,createHashHistory$1 as $createHashHistory,createMemoryHistory$1 as $createMemoryHistory,createTransitionManager$1 as $createTransitionManager,index as $index,invariant$1 as $invariant,resolvePathname$1 as $resolvePathname,valueEqual$1 as $valueEqual,warning$2 as $warning,canUseDOM,getConfirmation,supportsHistory,supportsPopStateOnHashChange,supportsGoWithoutReloadUsingHash,isExtraneousPopstateEvent,createLocation as createLocation$1,locationsAreEqual as locationsAreEqual$1,addLeadingSlash,stripLeadingSlash,hasBasename,stripBasename,stripTrailingSlash,parsePath as parsePath$1,createPath as createPath$1,createBrowserHistory as $createBrowserHistoryDefault,createHashHistory as $createHashHistoryDefault,createMemoryHistory as $createMemoryHistoryDefault,createTransitionManager as $createTransitionManagerDefault,createBrowserHistory,createHashHistory,createMemoryHistory,createLocation,locationsAreEqual,parsePath,createPath,invariant as $invariantDefault,resolvePathname as $resolvePathnameDefault,valueEqual as $valueEqualDefault,warning$1 as $warningDefault};